(function() {
    var type_impls = Object.fromEntries([["async_fence",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#267\">Source</a></span><a href=\"#impl-Clone-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#269\">Source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/clone.rs.html#174\">Source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","async_fence::core::FenceWaker"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.41.0\">1.41.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#276\">Source</a></span><a href=\"#impl-Debug-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#277\">Source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","async_fence::core::FenceWaker"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-MaybeUninit%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#285\">Source</a><a href=\"#impl-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.36.0\">1.36.0 (const: 1.36.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#307\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.new\" class=\"fn\">new</a>(val: T) -&gt; <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given value.\nIt is safe to call <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init\"><code>assume_init</code></a> on the return value of this function.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>v: MaybeUninit&lt;Vec&lt;u8&gt;&gt; = MaybeUninit::new(<span class=\"macro\">vec!</span>[<span class=\"number\">42</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.uninit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.36.0\">1.36.0 (const: 1.36.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#330\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.uninit\" class=\"fn\">uninit</a>() -&gt; <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<p>See the <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">type-level documentation</a> for some examples.</p>\n<h5 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>v: MaybeUninit&lt;String&gt; = MaybeUninit::uninit();</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.zeroed\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.75.0\">1.36.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#380\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.zeroed\" class=\"fn\">zeroed</a>() -&gt; <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, with the memory being\nfilled with <code>0</code> bytes. It depends on <code>T</code> whether that already makes for\nproper initialization. For example, <code>MaybeUninit&lt;usize&gt;::zeroed()</code> is initialized,\nbut <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code> is not because references must not\nbe null.</p>\n<p>Note that if <code>T</code> has padding bytes, those bytes are <em>not</em> preserved when the\n<code>MaybeUninit&lt;T&gt;</code> value is returned from this function, so those bytes will <em>not</em> be zeroed.</p>\n<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.\nIt is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>\n<h5 id=\"example-2\"><a class=\"doc-anchor\" href=\"#example-2\">§</a>Example</h5>\n<p>Correct usage of this function: initializing a struct with zero, where all\nfields of the struct can hold the bit-pattern 0 as a valid value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;(u8, bool)&gt;::zeroed();\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(x, (<span class=\"number\">0</span>, <span class=\"bool-val\">false</span>));</code></pre></div>\n<p>This can be used in const contexts, such as to indicate the end of static arrays for\nplugin registration.</p>\n<p><em>Incorrect</em> usage of this function: calling <code>x.zeroed().assume_init()</code>\nwhen <code>0</code> is not a valid bit-pattern for the type:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">enum </span>NotZero { One = <span class=\"number\">1</span>, Two = <span class=\"number\">2 </span>}\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;(u8, NotZero)&gt;::zeroed();\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"comment\">// Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n// This is undefined behavior. ⚠️</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const since 1.85.0\">1.55.0 (const: 1.85.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#474\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.write\" class=\"fn\">write</a>(&amp;mut self, val: T) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Sets the value of the <code>MaybeUninit&lt;T&gt;</code>.</p>\n<p>This overwrites any previous value without dropping it, so be careful\nnot to use this twice unless you want to skip running the destructor.\nFor your convenience, this also returns a mutable reference to the\n(now safely initialized) contents of <code>self</code>.</p>\n<p>As the content is stored inside a <code>MaybeUninit</code>, the destructor is not\nrun for the inner data if the MaybeUninit leaves scope without a call to\n<a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init\"><code>assume_init</code></a>, <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init_drop\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init_drop\"><code>assume_init_drop</code></a>, or similar. Code that receives\nthe mutable reference returned by this function needs to keep this in\nmind. The safety model of Rust regards leaks as safe, but they are\nusually still undesirable. This being said, the mutable reference\nbehaves like any other mutable reference would, so assigning a new value\nto it will drop the old content.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u8&gt;&gt;::uninit();\n\n{\n    <span class=\"kw\">let </span>hello = x.write((<span class=\"kw-2\">&amp;</span><span class=\"string\">b\"Hello, world!\"</span>).to_vec());\n    <span class=\"comment\">// Setting hello does not leak prior allocations, but drops them\n    </span><span class=\"kw-2\">*</span>hello = (<span class=\"kw-2\">&amp;</span><span class=\"string\">b\"Hello\"</span>).to_vec();\n    hello[<span class=\"number\">0</span>] = <span class=\"string\">'h' </span><span class=\"kw\">as </span>u8;\n}\n<span class=\"comment\">// x is initialized now:\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"hello\"</span>, s.as_slice());</code></pre></div>\n<p>This usage of the method causes a leak:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;String&gt;::uninit();\n\nx.write(<span class=\"string\">\"Hello\"</span>.to_string());\n<span class=\"comment\">// This leaks the contained string:\n</span>x.write(<span class=\"string\">\"hello\"</span>.to_string());\n<span class=\"comment\">// x is initialized now:\n</span><span class=\"kw\">let </span>s = <span class=\"kw\">unsafe </span>{ x.assume_init() };</code></pre></div>\n<p>This method can be used to avoid unsafe in some cases. The example below\nshows a part of an implementation of a fixed sized arena that lends out\npinned references.\nWith <code>write</code>, we can avoid the need to write through a raw pointer:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>core::pin::Pin;\n<span class=\"kw\">use </span>core::mem::MaybeUninit;\n\n<span class=\"kw\">struct </span>PinArena&lt;T&gt; {\n    memory: Box&lt;[MaybeUninit&lt;T&gt;]&gt;,\n    len: usize,\n}\n\n<span class=\"kw\">impl </span>&lt;T&gt; PinArena&lt;T&gt; {\n    <span class=\"kw\">pub fn </span>capacity(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; usize {\n        <span class=\"self\">self</span>.memory.len()\n    }\n    <span class=\"kw\">pub fn </span>push(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>, val: T) -&gt; Pin&lt;<span class=\"kw-2\">&amp;mut </span>T&gt; {\n        <span class=\"kw\">if </span><span class=\"self\">self</span>.len &gt;= <span class=\"self\">self</span>.capacity() {\n            <span class=\"macro\">panic!</span>(<span class=\"string\">\"Attempted to push to a full pin arena!\"</span>);\n        }\n        <span class=\"kw\">let </span>ref_ = <span class=\"self\">self</span>.memory[<span class=\"self\">self</span>.len].write(val);\n        <span class=\"self\">self</span>.len += <span class=\"number\">1</span>;\n        <span class=\"kw\">unsafe </span>{ Pin::new_unchecked(ref_) }\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.59.0\">1.36.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#517\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.as_ptr\" class=\"fn\">as_ptr</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.\nWriting to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\nx.write(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"comment\">// Create a reference into the `MaybeUninit&lt;T&gt;`. This is okay because we initialized it.\n</span><span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x.as_ptr() };\n<span class=\"macro\">assert_eq!</span>(x_vec.len(), <span class=\"number\">3</span>);</code></pre></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x.as_ptr() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>\n<p>(Notice that the rules around references to uninitialized data are not finalized yet, but\nuntil they are, it is advisable to avoid them.)</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.83.0\">1.36.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#559\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.as_mut_ptr\" class=\"fn\">as_mut_ptr</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.pointer.html\">*mut T</a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\nx.write(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"comment\">// Create a reference into the `MaybeUninit&lt;Vec&lt;u32&gt;&gt;`.\n// This is okay because we initialized it.\n</span><span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>x.as_mut_ptr() };\nx_vec.push(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(x_vec.len(), <span class=\"number\">4</span>);</code></pre></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec = <span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;mut *</span>x.as_mut_ptr() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>\n<p>(Notice that the rules around references to uninitialized data are not finalized yet, but\nuntil they are, it is advisable to avoid them.)</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assume_init\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0, const since 1.59.0\">1.36.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#614\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.assume_init\" class=\"fn\">assume_init</a>(self) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Extracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This is a great way\nto ensure that the data will get dropped, because the resulting <code>T</code> is\nsubject to the usual drop handling.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized\nstate. Calling this when the content is not yet fully initialized causes immediate undefined\nbehavior. The <a href=\"#initialization-invariant\">type-level documentation</a> contains more information about\nthis initialization invariant.</p>\n<p>On top of that, remember that most types have additional invariants beyond merely\nbeing considered initialized at the type level. For example, a <code>1</code>-initialized <a href=\"../../std/vec/struct.Vec.html\"><code>Vec&lt;T&gt;</code></a>\nis considered initialized (under the current implementation; this does not constitute\na stable guarantee) because the only requirement the compiler knows about it\nis that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause\n<em>immediate</em> undefined behavior, but will cause undefined behavior with most\nsafe operations (including dropping it).</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;bool&gt;::uninit();\nx.write(<span class=\"bool-val\">true</span>);\n<span class=\"kw\">let </span>x_init = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"macro\">assert_eq!</span>(x_init, <span class=\"bool-val\">true</span>);</code></pre></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_init = <span class=\"kw\">unsafe </span>{ x.assume_init() };\n<span class=\"comment\">// `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assume_init_read\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0, const since 1.75.0\">1.60.0 (const: 1.75.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#684\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.assume_init_read\" class=\"fn\">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Reads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject\nto the usual drop handling.</p>\n<p>Whenever possible, it is preferable to use <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init\"><code>assume_init</code></a> instead, which\nprevents duplicating the content of the <code>MaybeUninit&lt;T&gt;</code>.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized\nstate. Calling this when the content is not yet fully initialized causes undefined\nbehavior. The <a href=\"#initialization-invariant\">type-level documentation</a> contains more information about\nthis initialization invariant.</p>\n<p>Moreover, similar to the <a href=\"https://doc.rust-lang.org/nightly/core/ptr/fn.read.html\" title=\"fn core::ptr::read\"><code>ptr::read</code></a> function, this function creates a\nbitwise copy of the contents, regardless whether the contained type\nimplements the <a href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\"><code>Copy</code></a> trait or not. When using multiple copies of the\ndata (by calling <code>assume_init_read</code> multiple times, or first calling\n<code>assume_init_read</code> and then <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init\"><code>assume_init</code></a>), it is your responsibility\nto ensure that data may indeed be duplicated.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<p>Correct usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;u32&gt;::uninit();\nx.write(<span class=\"number\">13</span>);\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// `u32` is `Copy`, so we may read multiple times.\n</span><span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"macro\">assert_eq!</span>(x1, x2);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;<span class=\"prelude-ty\">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();\nx.write(<span class=\"prelude-val\">None</span>);\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// Duplicating a `None` value is okay, so we may read multiple times.\n</span><span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"macro\">assert_eq!</span>(x1, x2);</code></pre></div>\n<p><em>Incorrect</em> usage of this method:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;<span class=\"prelude-ty\">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();\nx.write(<span class=\"prelude-val\">Some</span>(<span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]));\n<span class=\"kw\">let </span>x1 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"kw\">let </span>x2 = <span class=\"kw\">unsafe </span>{ x.assume_init_read() };\n<span class=\"comment\">// We now created two copies of the same vector, leading to a double-free ⚠️ when\n// they both get dropped!</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assume_init_drop\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#715\">Source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.assume_init_drop\" class=\"fn\">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops the contained value in place.</p>\n<p>If you have ownership of the <code>MaybeUninit</code>, you can also use\n<a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init\" title=\"method core::mem::maybe_uninit::MaybeUninit::assume_init\"><code>assume_init</code></a> as an alternative.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is\nin an initialized state. Calling this when the content is not yet fully\ninitialized causes undefined behavior.</p>\n<p>On top of that, all additional invariants of the type <code>T</code> must be\nsatisfied, as the <code>Drop</code> implementation of <code>T</code> (or its members) may\nrely on this. For example, setting a <code>Vec&lt;T&gt;</code> to an invalid but\nnon-null address makes it initialized (under the current implementation;\nthis does not constitute a stable guarantee), because the only\nrequirement the compiler knows about it is that the data pointer must be\nnon-null. Dropping such a <code>Vec&lt;T&gt;</code> however will cause undefined\nbehavior.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assume_init_ref\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const since 1.59.0\">1.55.0 (const: 1.59.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#781\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.assume_init_ref\" class=\"fn\">assume_init_ref</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.reference.html\">&amp;T</a></h4></section></summary><div class=\"docblock\"><p>Gets a shared reference to the contained value.</p>\n<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been\ninitialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use\nof <code>.assume_init()</code>).</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>Calling this when the content is not yet fully initialized causes undefined\nbehavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really\nis in an initialized state.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5><h6 id=\"correct-usage-of-this-method\"><a class=\"doc-anchor\" href=\"#correct-usage-of-this-method\">§</a>Correct usage of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"comment\">// Initialize `x`:\n</span>x.write(<span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"comment\">// Now that our `MaybeUninit&lt;_&gt;` is known to be initialized, it is okay to\n// create a shared reference to it:\n</span><span class=\"kw\">let </span>x: <span class=\"kw-2\">&amp;</span>Vec&lt;u32&gt; = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// SAFETY: `x` has been initialized.\n    </span>x.assume_init_ref()\n};\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span><span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre></div>\n<h6 id=\"incorrect-usages-of-this-method\"><a class=\"doc-anchor\" href=\"#incorrect-usages-of-this-method\">§</a><em>Incorrect</em> usages of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();\n<span class=\"kw\">let </span>x_vec: <span class=\"kw-2\">&amp;</span>Vec&lt;u32&gt; = <span class=\"kw\">unsafe </span>{ x.assume_init_ref() };\n<span class=\"comment\">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{cell::Cell, mem::MaybeUninit};\n\n<span class=\"kw\">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();\n<span class=\"comment\">// Initialize the `MaybeUninit` using `Cell::set`:\n</span><span class=\"kw\">unsafe </span>{\n    b.assume_init_ref().set(<span class=\"bool-val\">true</span>);\n   <span class=\"comment\">// ^^^^^^^^^^^^^^^\n   // Reference to an uninitialized `Cell&lt;bool&gt;`: UB!\n</span>}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assume_init_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.55.0, const since 1.84.0\">1.55.0 (const: 1.84.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#898\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.assume_init_mut\" class=\"fn\">assume_init_mut</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class=\"docblock\"><p>Gets a mutable (unique) reference to the contained value.</p>\n<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been\ninitialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use\nof <code>.assume_init()</code>).</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">§</a>Safety</h5>\n<p>Calling this when the content is not yet fully initialized causes undefined\nbehavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really\nis in an initialized state. For instance, <code>.assume_init_mut()</code> cannot be used to\ninitialize a <code>MaybeUninit</code>.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5><h6 id=\"correct-usage-of-this-method-1\"><a class=\"doc-anchor\" href=\"#correct-usage-of-this-method-1\">§</a>Correct usage of this method:</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">extern </span><span class=\"string\">\"C\" </span>{\n    <span class=\"doccomment\">/// Initializes *all* the bytes of the input buffer.\n    </span><span class=\"kw\">fn </span>initialize_buffer(buf: <span class=\"kw-2\">*mut </span>[u8; <span class=\"number\">1024</span>]);\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = MaybeUninit::&lt;[u8; <span class=\"number\">1024</span>]&gt;::uninit();\n\n<span class=\"comment\">// Initialize `buf`:\n</span><span class=\"kw\">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }\n<span class=\"comment\">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.\n// To assert our buffer has been initialized without copying it, we upgrade\n// the `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` to a `&amp;mut [u8; 1024]`:\n</span><span class=\"kw\">let </span>buf: <span class=\"kw-2\">&amp;mut </span>[u8; <span class=\"number\">1024</span>] = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// SAFETY: `buf` has been initialized.\n    </span>buf.assume_init_mut()\n};\n\n<span class=\"comment\">// Now we can use `buf` as a normal slice:\n</span>buf.sort_unstable();\n<span class=\"macro\">assert!</span>(\n    buf.windows(<span class=\"number\">2</span>).all(|pair| pair[<span class=\"number\">0</span>] &lt;= pair[<span class=\"number\">1</span>]),\n    <span class=\"string\">\"buffer is sorted\"</span>,\n);</code></pre></div>\n<h6 id=\"incorrect-usages-of-this-method-1\"><a class=\"doc-anchor\" href=\"#incorrect-usages-of-this-method-1\">§</a><em>Incorrect</em> usages of this method:</h6>\n<p>You cannot use <code>.assume_init_mut()</code> to initialize a value:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw-2\">*</span>b.assume_init_mut() = <span class=\"bool-val\">true</span>;\n    <span class=\"comment\">// We have created a (mutable) reference to an uninitialized `bool`!\n    // This is undefined behavior. ⚠️\n</span>}</code></pre></div>\n<p>For instance, you cannot <a href=\"../../std/io/trait.Read.html\"><code>Read</code></a> into an uninitialized buffer:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{io, mem::MaybeUninit};\n\n<span class=\"kw\">fn </span>read_chunk (reader: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'_ </span><span class=\"kw-2\">mut </span><span class=\"kw\">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class=\"number\">64</span>]&gt;\n{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buffer = MaybeUninit::&lt;[u8; <span class=\"number\">64</span>]&gt;::uninit();\n    reader.read_exact(<span class=\"kw\">unsafe </span>{ buffer.assume_init_mut() })<span class=\"question-mark\">?</span>;\n                            <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^^^^\n                            // (mutable) reference to uninitialized memory!\n                            // This is undefined behavior.\n    </span><span class=\"prelude-val\">Ok</span>(<span class=\"kw\">unsafe </span>{ buffer.assume_init() })\n}</code></pre></div>\n<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::{mem::MaybeUninit, ptr};\n\n<span class=\"kw\">struct </span>Foo {\n    a: u32,\n    b: u8,\n}\n\n<span class=\"kw\">let </span>foo: Foo = <span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();\n    ptr::write(<span class=\"kw-2\">&amp;mut </span>foo.assume_init_mut().a <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u32, <span class=\"number\">1337</span>);\n                 <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    </span>ptr::write(<span class=\"kw-2\">&amp;mut </span>foo.assume_init_mut().b <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u8, <span class=\"number\">42</span>);\n                 <span class=\"comment\">// ^^^^^^^^^^^^^^^^^^^^^\n                 // (mutable) reference to uninitialized memory!\n                 // This is undefined behavior.\n    </span>foo.assume_init()\n};</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.array_assume_init\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#935\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.array_assume_init\" class=\"fn\">array_assume_init</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.usize.html\">usize</a>&gt;(\n    array: [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.array.html\">N</a>],\n) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.array.html\">[T; N]</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_array_assume_init</code>)</span></div></span></summary><div class=\"docblock\"><p>Extracts the values from an array of <code>MaybeUninit</code> containers.</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">§</a>Safety</h5>\n<p>It is up to the caller to guarantee that all elements of the array are\nin an initialized state.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_array_assume_init)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array: [MaybeUninit&lt;i32&gt;; <span class=\"number\">3</span>] = [MaybeUninit::uninit(); <span class=\"number\">3</span>];\narray[<span class=\"number\">0</span>].write(<span class=\"number\">0</span>);\narray[<span class=\"number\">1</span>].write(<span class=\"number\">1</span>);\narray[<span class=\"number\">2</span>].write(<span class=\"number\">2</span>);\n\n<span class=\"comment\">// SAFETY: Now safe as we initialised all elements\n</span><span class=\"kw\">let </span>array = <span class=\"kw\">unsafe </span>{\n    MaybeUninit::array_assume_init(array)\n};\n\n<span class=\"macro\">assert_eq!</span>(array, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_bytes\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#965\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.as_bytes\" class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this <code>MaybeUninit</code> as a slice of potentially uninitialized bytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>val = <span class=\"number\">0x12345678_i32</span>;\n<span class=\"kw\">let </span>uninit = MaybeUninit::new(val);\n<span class=\"kw\">let </span>uninit_bytes = uninit.as_bytes();\n<span class=\"kw\">let </span>bytes = <span class=\"kw\">unsafe </span>{ uninit_bytes.assume_init_ref() };\n<span class=\"macro\">assert_eq!</span>(bytes, val.to_ne_bytes());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_bytes_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#996\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.as_bytes_mut\" class=\"fn\">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contents of this <code>MaybeUninit</code> as a mutable slice of potentially uninitialized\nbytes.</p>\n<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still\ncontain padding bytes which are left uninitialized.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(maybe_uninit_as_bytes)]\n</span><span class=\"kw\">use </span>std::mem::MaybeUninit;\n\n<span class=\"kw\">let </span>val = <span class=\"number\">0x12345678_i32</span>;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>uninit = MaybeUninit::new(val);\n<span class=\"kw\">let </span>uninit_bytes = uninit.as_bytes_mut();\n<span class=\"kw\">if </span><span class=\"macro\">cfg!</span>(target_endian = <span class=\"string\">\"little\"</span>) {\n    uninit_bytes[<span class=\"number\">0</span>].write(<span class=\"number\">0xcd</span>);\n} <span class=\"kw\">else </span>{\n    uninit_bytes[<span class=\"number\">3</span>].write(<span class=\"number\">0xcd</span>);\n}\n<span class=\"kw\">let </span>val2 = <span class=\"kw\">unsafe </span>{ uninit.assume_init() };\n<span class=\"macro\">assert_eq!</span>(val2, <span class=\"number\">0x123456cd</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_assume_init_ref\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1012\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_assume_init_ref\" class=\"fn\">slice_assume_init_ref</a>(slice: &amp;[<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent assume_init_ref method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.assume_init_ref\" title=\"method slice::assume_init_ref\"><code>slice::assume_init_ref</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_assume_init_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1023\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_assume_init_mut\" class=\"fn\">slice_assume_init_mut</a>(\n    slice: &amp;mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n) -&gt; &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent assume_init_mut method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.assume_init_mut\" title=\"method slice::assume_init_mut\"><code>slice::assume_init_mut</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_as_ptr\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1031\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_as_ptr\" class=\"fn\">slice_as_ptr</a>(this: &amp;[<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.pointer.html\">*const T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Gets a pointer to the first element of the array.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_as_mut_ptr\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1038\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_as_mut_ptr\" class=\"fn\">slice_as_mut_ptr</a>(this: &amp;mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.pointer.html\">*mut T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Gets a mutable pointer to the first element of the array.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.copy_from_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1048-1050\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.copy_from_slice\" class=\"fn\">copy_from_slice</a>&lt;'a&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    src: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a>,\n) -&gt; &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent write_copy_of_slice method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.write_copy_of_slice\" title=\"method slice::write_copy_of_slice\"><code>slice::write_copy_of_slice</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from_slice\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1061-1063\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.clone_from_slice\" class=\"fn\">clone_from_slice</a>&lt;'a&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    src: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a>,\n) -&gt; &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent write_clone_of_slice method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.write_clone_of_slice\" title=\"method slice::write_clone_of_slice\"><code>slice::write_clone_of_slice</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1074-1076\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.fill\" class=\"fn\">fill</a>&lt;'a&gt;(this: &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], value: T) -&gt; &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent write_filled method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.write_filled\" title=\"method slice::write_filled\"><code>slice::write_filled</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_with\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1087-1089\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.fill_with\" class=\"fn\">fill_with</a>&lt;'a, F&gt;(this: &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;], f: F) -&gt; &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a><div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>() -&gt; T,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent write_with method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.write_with\" title=\"method slice::write_with\"><code>slice::write_with</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_from\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1100-1105\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.fill_from\" class=\"fn\">fill_from</a>&lt;'a, I&gt;(\n    this: &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;],\n    it: I,\n) -&gt; (&amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html\">[T]</a>, &amp;'a mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;])<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent write_iter method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_fill</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.write_iter\" title=\"method slice::write_iter\"><code>slice::write_iter</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_as_bytes\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1116\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_as_bytes\" class=\"fn\">slice_as_bytes</a>(this: &amp;[<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;[<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent as_bytes method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.as_bytes\" title=\"method slice::as_bytes\"><code>slice::as_bytes</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.slice_as_bytes_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1126\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html#tymethod.slice_as_bytes_mut\" class=\"fn\">slice_as_bytes_mut</a>(this: &amp;mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;mut [<a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.u8.html\">u8</a>&gt;]</h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.83.0: replaced by inherent as_bytes_mut method; will eventually be removed</span></div><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class=\"docblock\"><p>Deprecated version of <a href=\"https://doc.rust-lang.org/nightly/core/primitive.slice.html#method.as_bytes_mut\" title=\"method slice::as_bytes_mut\"><code>slice::as_bytes_mut</code></a>.</p>\n</div></details></div></details>",0,"async_fence::core::FenceWaker"],["<section id=\"impl-Copy-for-MaybeUninit%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.36.0\">1.36.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#258\">Source</a></span><a href=\"#impl-Copy-for-MaybeUninit%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a> for <a class=\"union\" href=\"https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h3></section>","Copy","async_fence::core::FenceWaker"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[66320]}